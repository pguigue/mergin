# Copyright (C) Lutra Consulting Limited
#
# SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-MerginMaps-Commercial

import functools
from datetime import datetime
from blinker import signal
from flask import current_app, render_template
from flask_login import current_user
from itsdangerous import URLSafeTimedSerializer
from sqlalchemy import or_

from .commands import add_commands
from .db_events import register_events
from .config import Configuration
from .models import User, UserProfile
from .. import db

user_deleted = signal("user_deleted")
user_created = signal("user_created")


def register(app):
    """Register mergin auth module in Flask app
    Adds Flask blueprint with autogenerated Flask/Connexion routes from openAPI definition.
    Register db events/hooks.
    """
    app.config.from_object(Configuration)
    app.connexion_app.add_api(
        "auth/api.yaml",
        base_path="/",
        options={"swagger_ui": False, "serve_spec": False},
        validate_responses=True,
    )
    # this is a hack to modify dict and name of flask blueprint registered with "base_path" name
    # due to lack of connexion flexibility for flask blueprint naming
    app.blueprints["/"].name = "auth"
    app.blueprints["auth"] = app.blueprints.pop("/")
    register_events()
    add_commands(app)


_permissions = {}


def register_permission(name, fn):
    _permissions[name] = fn


register_permission("admin", lambda user: user.is_admin)


def auth_required(f=None, permissions=None):
    if f is None:
        if permissions:
            permissions_fn = []
            for name in permissions:
                if name not in _permissions:
                    raise KeyError("Unknown permission: {}".format(name))
                permissions_fn.append(_permissions[name])
        return functools.partial(auth_required, permissions=permissions_fn)

    @functools.wraps(f)
    def wrapped_func(*args, **kwargs):
        if not current_user or not current_user.is_authenticated:
            return "Authentication information is missing or invalid.", 401
        if permissions:
            for check_permission in permissions:
                if not check_permission(current_user):
                    return "Permission denied.", 403
        return f(*args, **kwargs)

    return wrapped_func


def authenticate(login, password):
    if "@" in login:
        query = {"email": login}
    else:
        query = {"username": login}
    user = User.query.filter_by(**query).one_or_none()
    if user and user.check_password(password):
        return user


def generate_confirmation_token(app, email):
    serializer = URLSafeTimedSerializer(app.config["SECRET_KEY"])
    return serializer.dumps(email, salt=app.config["SECURITY_PASSWORD_SALT"])


def confirm_token(token, expiration=3600 * 24 * 3):
    serializer = URLSafeTimedSerializer(current_app.config["SECRET_KEY"])
    try:
        email = serializer.loads(
            token, salt=current_app.config["SECURITY_PASSWORD_SALT"], max_age=expiration
        )
    except:
        return
    return email


def send_confirmation_email(app, user, url, template, header):
    from ..celery import send_email_async

    token = generate_confirmation_token(app, user.email)
    confirm_url = f"{url}/{token}"
    html = render_template(template, subject=header, confirm_url=confirm_url, user=user)
    email_data = {
        "subject": header,
        "html": html,
        "recipients": [user.email],
        "sender": app.config["MAIL_DEFAULT_SENDER"],
    }
    send_email_async.delay(**email_data)


def do_register_user(username, email, password):
    user = User(username.strip(), email.strip(), password, False)
    user.profile = UserProfile()
    db.session.add(user)
    db.session.commit()
    return user


def inactivate_user(user: User) -> None:
    """Inactivate user account and remove explicitly shared projects as well clean references to created projects.
    User is then safe to be removed.
    """
    from ..sync.models import Project, ProjectAccess

    shared_projects = Project.query.filter(
        or_(
            Project.access.has(ProjectAccess.owners.contains([user.id])),
            Project.access.has(ProjectAccess.writers.contains([user.id])),
            Project.access.has(ProjectAccess.readers.contains([user.id])),
        )
    ).all()

    for p in shared_projects:
        for key in ("owners", "writers", "readers"):
            value = set(getattr(p.access, key))
            if user.id in value:
                value.remove(user.id)
            setattr(p.access, key, list(value))
        db.session.add(p)

    # remove ref to creator to allow for user removal
    created_projects = Project.query.filter_by(creator_id=user.id).all()
    for p in created_projects:
        p.creator_id = None
        db.session.add(p)

    # inactivate user account to prevent login and mark for clean up
    user.active = False
    user.inactive_since = datetime.utcnow()
    db.session.add(user)
    db.session.commit()
